{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}{\f2\fnil\fcharset0 Calibri;}}
{\colortbl ;\red63\green127\blue95;\red0\green0\blue255;\red127\green0\blue85;\red0\green0\blue0;\red42\green0\blue255;\red0\green80\blue50;\red100\green40\blue128;\red224\green224\blue224;\red0\green0\blue192;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\cf1\f0\fs20\lang9 //###########################################################################\cf0\par
\cf1 //\cf0\par
\cf1 // FILE:   enet_lwip.c\cf0\par
\cf1 //\cf0\par
\cf1 // TITLE:  lwIP based Ethernet Example.\cf0\par
\cf1 //\cf0\par
\cf1 // Example to demonstrate UDP socket (for \ul daikin\ulnone  customer)\cf0\par
\cf1 // buf_rx,buf_tx are the watch variables which can be used or updated in the\cf0\par
\cf1 // main application based on the requirement.\cf0\par
\cf1 // \cf0\par
\cf1 // Test setup\cf0\par
\cf1 //\cf0\par
\cf1 // F2838x Control Card connected to a PC/\ul laptop\ulnone   on the Ethernet port.\cf0\par
\cf1 // PC/\ul laptop\ulnone  runs the SocketTest/\f1\'e2\'80\'99Packet \ul\f0 Sender\f1\'e2\ulnone\'80\'99 software, configured for the IP Address and port . \\\cf0\f0\par
\cf1 // Keywords \f1\'e2\'80\f0\'98\f1 START\'e2\'80\'99 and \'e2\'80\f0\'98\f1 STOP\'e2\'80\'99 are used to send and stop receiving messages respectively\cf0\f0\par
\cf1 // Received data is stored in \f1\'e2\'80\f0\'98\f1 buf_rx\'e2\'80\'99 array and data to be transmitted is stored in \'e2\'80\f0\'98\f1 buf_tx\'e2\'80\'99 array on CM core of F2838x device\cf0\f0\par
\cf1 // Examples is Interrupt based with a callback function \f1\'e2\'80\f0\'98\f1 udp_rx_callback\'e2\'80\'99 which handles the received data from the SocketTest/Packet Sender software.\cf0\f0\par
\cf1 //\cf0\par
\cf1 //###########################################################################\cf0\par
\cf1 // $TI Release: $\cf0\par
\cf1 // $Release Date: $\cf0\par
\cf1 // $Copyright:\cf0\par
\cf1 // Copyright (C) 2022 Texas Instruments Incorporated - {{\field{\*\fldinst{HYPERLINK http://www.ti.com }}{\fldrslt{http://www.ti.com\ul0\cf0}}}}\cf0\f0\fs20\par
\cf1 //\cf0\par
\cf1 // Redistribution and use in source and binary forms, with or without \cf0\par
\cf1 // modification, are permitted provided that the following conditions \cf0\par
\cf1 // are met:\cf0\par
\cf1 // \cf0\par
\cf1 //   Redistributions of source code must retain the above copyright \cf0\par
\cf1 //   notice, this list of conditions and the following disclaimer.\cf0\par
\cf1 // \cf0\par
\cf1 //   Redistributions in binary form must reproduce the above copyright\cf0\par
\cf1 //   notice, this list of conditions and the following disclaimer in the \cf0\par
\cf1 //   documentation and/or other materials provided with the   \cf0\par
\cf1 //   distribution.\cf0\par
\cf1 // \cf0\par
\cf1 //   Neither the name of Texas Instruments Incorporated nor the names of\cf0\par
\cf1 //   its contributors may be used to endorse or promote products derived\cf0\par
\cf1 //   from this software without specific prior written permission.\cf0\par
\cf1 // \cf0\par
\cf1 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \cf0\par
\cf1 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \cf0\par
\cf1 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\cf0\par
\cf1 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \cf0\par
\cf1 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \cf0\par
\cf1 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \cf0\par
\cf1 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\cf0\par
\cf1 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\cf0\par
\cf1 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \cf0\par
\cf1 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \cf0\par
\cf1 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\cf0\par
\cf1 // $\cf0\par
\cf1 //###########################################################################\cf0\par
\par
\par
\cf3\b #include\cf4\b0  \cf5 <string.h>\cf0\par
\par
\cf3\b #include\cf4\b0  \cf5 "inc/hw_ints.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "inc/hw_memmap.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "inc/hw_nvic.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "inc/hw_types.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "inc/hw_sysctl.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "inc/hw_emac.h"\cf0\par
\par
\cf3\b #include\cf4\b0  \cf5 "driverlib_cm/ethernet.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "driverlib_cm/gpio.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "driverlib_cm/interrupt.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "driverlib_cm/flash.h"\cf0\par
\par
\cf3\b #include\cf4\b0  \cf5 "driverlib_cm/sysctl.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "driverlib_cm/systick.h"\cf0\par
\par
\cf3\b #include\cf4\b0  \cf5 "utils/lwiplib.h"\cf0\par
\cf3\b #include\cf4\b0  \cf5 "board_drivers/pinout.h"\cf0\par
\par
\par
\cf3\b #include\cf4\b0  \cf5 "lwipopts.h"\cf0\par
\par
\par
\par
\cf3\b #define\cf4\b0  PAYLOAD 1088\cf0\par
\par
\cf3\b volatile\cf4\b0  \cf6 uint32_t\cf4  msTime=0;\cf0\par
\par
\par
\cf3\b volatile\cf4\b0  bool flag_TX_frame_UDP=true;\cf0\par
\par
\par
\cf3\b #define\cf4\b0  MAKE_IP_ADDRESS(a0,a1,a2,a3) (((a0<<24) & 0xFF000000) | ((a1<<16) & 0x00FF0000) | ((a2<<8)  & 0x0000FF00) | (a3 & 0x000000FF) )\cf0\par
\par
\cf4 bool Connected_udp_28000 = false;\cf0\par
\par
\cf6 uint16_t\cf4  cnt_Connected_udp_28000 = 0;\cf0\par
\par
\cf1 //\cf0\par
\cf1 // Defines\cf0\par
\cf1 //\cf0\par
\cf3\b #define\cf4\b0  IPC_CMD_READ_MEM   0x1001\cf0\par
\cf3\b #define\cf4\b0  TEST_PASS          0x5555\cf0\par
\cf3\b #define\cf4\b0  TEST_FAIL          0xAAAA\cf0\par
\par
\cf1 //\cf0\par
\cf1 // Defines\cf0\par
\cf1 //\cf0\par
\cf3\b #define\cf4\b0  PACKET_LENGTH 132\cf0\par
\par
\cf3\b struct\cf4\b0  \cf6 udp_pcb\cf4  *g_upcb;\cf0\par
\par
\par
\par
\cf6 u8_t\cf4  buf_rx[PAYLOAD];\cf0\par
\cf6 uint32_t\cf4  buf_tx[PAYLOAD];\cf0\par
\cf3\b char\cf4\b0  * buf_tx_start_msg = \cf5 "Something to show UDP is working \\n"\cf4 ;\cf0\par
\cf6 uint32_t\cf4  buf_tx_start_msg_count = 35;\cf0\par
\par
\cf6 uint16_t\cf4  cont_rx_udp = 0;\cf0\par
\par
\cf3\b struct\cf4\b0  \cf6 pbuf\cf4  *pbuf1_tx;\cf0\par
\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 //! \\\ul addtogroup\ulnone  master_example_list\cf0\par
\cf1 //! <h1>Ethernet with lwIP (enet_lwip)</h1>\cf0\par
\cf1 //!\cf0\par
\cf1 //! This example application demonstrates the operation of the F2838x\cf0\par
\cf1 //! \ul microcontroller\ulnone  Ethernet controller using the lwIP TCP/IP Stack. Once\cf0\par
\cf1 //! programmed, the device sits endlessly waiting for ICMP ping requests. It\cf0\par
\cf1 //! has a static IP address. To ping the device, the sender has to be in the\cf0\par
\cf1 //! same network. The stack also supports ARP.\cf0\par
\cf1 //!\cf0\par
\cf1 //! For additional details on lwIP, refer to the lwIP web page at:\cf0\par
\cf1 //! {{\field{\*\fldinst{HYPERLINK http://savannah.nongnu.org/projects/lwip/ }}{\fldrslt{http://savannah.nongnu.org/projects/lwip/\ul0\cf0}}}}\cf0\f0\fs20\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\par
\cf1 // These are defined by the linker (see device linker command file)\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  RamfuncsLoadStart;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  RamfuncsLoadSize;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  RamfuncsRunStart;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  RamfuncsLoadEnd;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  RamfuncsRunEnd;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  RamfuncsRunSize;\cf0\par
\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  constLoadStart;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  constLoadEnd;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  constLoadSize;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  constRunStart;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  constRunEnd;\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint16_t\cf4  constRunSize;\cf0\par
\par
\cf3\b #define\cf4\b0  DEVICE_FLASH_WAITSTATES 2\cf0\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // Driver specific initialization code and macro.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\par
\cf3\b #define\cf4\b0  ETHERNET_NO_OF_RX_PACKETS   2U\cf0\par
\cf3\b #define\cf4\b0  ETHERNET_MAX_PACKET_LENGTH 1538U\cf0\par
\par
\cf3\b #define\cf4\b0  NUM_PACKET_DESC_RX_APPLICATION PBUF_POOL_SIZE \cf1 //8 - same as PBUF_POOL_SIZE\cf0\par
\par
\par
\cf6 Ethernet_Handle\cf4  emac_handle;\cf0\par
\cf6 Ethernet_InitConfig\cf4  *pInitCfg;\cf0\par
\cf6 uint32_t\cf4  Ethernet_numRxCallbackCustom = 0;\cf0\par
\cf6 uint32_t\cf4  releaseTxCount = 0;\cf0\par
\cf6 uint32_t\cf4  genericISRCustomcount = 0;\cf0\par
\cf6 uint32_t\cf4  genericISRCustomRBUcount = 0;\cf0\par
\cf6 uint32_t\cf4  genericISRCustomROVcount = 0;\cf0\par
\cf6 uint32_t\cf4  genericISRCustomRIcount = 0;\cf0\par
\par
\cf6 uint32_t\cf4  systickPeriodValue = 125000; \cf1 //15000000;\cf0\par
\cf6 Ethernet_Pkt_Desc\cf4   pktDescriptorRXCustom[NUM_PACKET_DESC_RX_APPLICATION];\cf0\par
\cf3\b extern\cf4\b0  \cf6 uint32_t\cf4  Ethernet_numGetPacketBufferCallback;\cf0\par
\cf3\b extern\cf4\b0  \cf6 Ethernet_Device\cf4  Ethernet_device_struct;\cf0\par
\cf6 uint8_t\cf4  Ethernet_rxBuffer[ETHERNET_NO_OF_RX_PACKETS *\cf0\par
\cf4                           ETHERNET_MAX_PACKET_LENGTH];\cf0\par
\par
\cf6 uint32_t\cf4  sendPacketFailedCount = 0;\cf0\par
\par
\cf6 uint8_t\cf4  mac_custom[6] = \{0xA8, 0x63, 0xF2, 0x00, 0x1D, 0x98\};\cf0\par
\par
\cf3\b extern\cf4\b0  \cf6 Ethernet_Pkt_Desc\cf4 *\cf0\par
\cf4\b lwIPEthernetIntHandler\b0 (\cf6 Ethernet_Pkt_Desc\cf4  *pPacket);\cf0\par
\par
\cf3\b void\cf4\b0  \b CM_init\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Disable the \ul watchdog\cf0\ulnone\par
\cf4     \cf1 //\cf0\par
\cf4     SysCtl_disableWatchdog();\cf0\par
\par
\cf3\b #ifdef\cf4\b0  _FLASH\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Copy time critical code and flash setup code to RAM. This includes the\cf0\par
\cf4     \cf1 // following functions: InitFlash();\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // The RamfuncsLoadStart, RamfuncsLoadSize, and RamfuncsRunStart symbols\cf0\par
\cf4     \cf1 // are created by the linker. Refer to the device .\ul cmd\ulnone  file.\cf0\par
\cf4     \cf1 // \ul Html\ulnone  pages are also being copied from flash to ram.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b memcpy\cf4\b0 (&RamfuncsRunStart, &RamfuncsLoadStart, (\cf6 size_t\cf4 )&RamfuncsLoadSize);\cf0\par
\cf4     \cf7\b memcpy\cf4\b0 (&constRunStart, &constLoadStart, (\cf6 size_t\cf4 )&constLoadSize);\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Call Flash Initialization to setup flash \ul waitstates\ulnone . This function must\cf0\par
\cf4     \cf1 // reside in RAM.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b Flash_initModule\cf4\b0 (FLASH0CTRL_BASE, FLASH0ECC_BASE, DEVICE_FLASH_WAITSTATES);\cf0\par
\cf3\b #endif\cf0\b0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Sets the NVIC vector table offset address.\cf0\par
\cf4     \cf1 //\cf0\par
\cf3\b #ifdef\cf4\b0  _FLASH\cf0\par
\cf4     Interrupt_setVectorTableOffset((\cf6 uint32_t\cf4 )vectorTableFlash);\cf0\par
\cf3\highlight8\b #else\cf0\highlight0\b0\par
\cf4\highlight8     Interrupt_setVectorTableOffset((uint32_t)vectorTableRAM);\cf0\highlight0\par
\cf3\highlight8\b #endif\cf0\highlight0\b0\par
\par
\cf4\}\cf0\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // HTTP \ul Webserver\ulnone  related \ul callbacks\ulnone  and definitions.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // Currently, this implemented as a pointer to function which is called when\cf0\par
\cf1 // corresponding query is received by the HTTP \ul webserver\ulnone  daemon. When more\cf0\par
\cf1 // features are needed to be added, it should be implemented as a separate\cf0\par
\cf1 // interface.\cf0\par
\cf1 //\cf0\par
\cf3\b void\cf4\b0  \b httpLEDToggle\b0 (\cf3\b void\cf4\b0 );\cf0\par
\cf3\b void\cf4\b0 (*ledtoggleFuncPtr)(\cf3\b void\cf4\b0 ) = &httpLEDToggle;\cf0\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // The interrupt handler for the SysTick interrupt.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\cf3\b void\cf0\b0\par
\cf4\b SysTickIntHandler\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Call the lwIP timer handler.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4  \cf1 //   lwIPTimer(systickPeriodValue);\cf0\par
\cf4        \cf7\b lwIPTimer\cf4\b0 (1);\cf0\par
\cf4\}\cf0\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 //  This function is a callback function called by the example to\cf0\par
\cf1 //  get a Packet Buffer. Has to return a ETHERNET_Pkt_Desc Structure.\cf0\par
\cf1 //  Rewrite this API for custom use case.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\cf6 Ethernet_Pkt_Desc\cf4 * \b Ethernet_getPacketBufferCustom\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Get the next packet descriptor from the descriptor pool\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf6 uint32_t\cf4  shortIndex = (Ethernet_numGetPacketBufferCallback + 3)\cf0\par
\cf4                 % NUM_PACKET_DESC_RX_APPLICATION;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Increment the book-keeping pointer which acts as a head pointer\cf0\par
\cf4     \cf1 // to the circular array of packet descriptor pool.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     Ethernet_numGetPacketBufferCallback++;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Update buffer length information to the newly procured packet\cf0\par
\cf4     \cf1 // descriptor.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     pktDescriptorRXCustom[shortIndex].\cf9 bufferLength\cf4  =\cf0\par
\cf4                                   ETHERNET_MAX_PACKET_LENGTH;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Update the receive buffer address in the packer descriptor.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     pktDescriptorRXCustom[shortIndex].\cf9 dataBuffer\cf4  =\cf0\par
\cf4                                       &Ethernet_device_struct.\cf9 rxBuffer\cf4  [ \\\cf0\par
\cf4                (ETHERNET_MAX_PACKET_LENGTH*Ethernet_device_struct.\cf9 rxBuffIndex\cf4 )];\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Update the receive buffer pool index.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     Ethernet_device_struct.\cf9 rxBuffIndex\cf4  += 1U;\cf0\par
\cf4     Ethernet_device_struct.\cf9 rxBuffIndex\cf4   = \\\cf0\par
\cf4     (Ethernet_device_struct.\cf9 rxBuffIndex\cf4 %ETHERNET_NO_OF_RX_PACKETS);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Receive buffer is usable from Address 0\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     pktDescriptorRXCustom[shortIndex].\cf9 dataOffset\cf4  = 0U;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Return this new descriptor to the driver.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf3\b return\cf4\b0  (&(pktDescriptorRXCustom[shortIndex]));\cf0\par
\cf4\}\cf0\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 //  This is a hook function and called by the driver when it receives a\cf0\par
\cf1 //  packet. Application is expected to replenish the buffer after consuming it.\cf0\par
\cf1 //  Has to return a ETHERNET_Pkt_Desc Structure.\cf0\par
\cf1 //  Rewrite this API for custom use case.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\cf6 Ethernet_Pkt_Desc\cf4 * \b Ethernet_receivePacketCallbackCustom\b0 (\cf0\par
\cf4         \cf6 Ethernet_Handle\cf4  handleApplication,\cf0\par
\cf4         \cf6 Ethernet_Pkt_Desc\cf4  *pPacket)\cf0\par
\cf4\{\cf0\par
\par
\cf4     \cf6 Ethernet_Pkt_Desc\cf4 * temp_eth_pkt;\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Book-keeping to maintain number of \ul callbacks\ulnone  received.\cf0\par
\cf4     \cf1 //\cf0\par
\cf3\highlight8\b #ifdef\cf4\b0  ETHERNET_DEBUG\cf0\highlight0\par
\cf4\highlight8     Ethernet_numRxCallbackCustom++;\cf0\highlight0\par
\cf3\highlight8\b #endif\cf0\highlight0\b0\par
\par
\par
\par
\cf4       \cf7\b Ethernet_disableRxDMAReception\cf4\b0 (EMAC_BASE,0);\cf0\par
\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // This is a placeholder for Application specific handling\cf0\par
\cf4     \cf1 // We are replenishing the buffer received with another buffer\cf0\par
\cf4     \cf1 //\cf0\par
\cf4   \cf1 //  return lwIPEthernetIntHandler(pPacket);\cf0\par
\par
\cf4       temp_eth_pkt=lwIPEthernetIntHandler(pPacket);\cf0\par
\par
\par
\cf4       \cf7\b Ethernet_enableRxDMAReception\cf4\b0 (EMAC_BASE,0);\cf0\par
\par
\cf4       \cf3\b return\cf4\b0  temp_eth_pkt;\cf0\par
\cf4\}\cf0\par
\par
\cf3\b void\cf4\b0  \b Ethernet_releaseTxPacketBufferCustom\b0 (\cf0\par
\cf4         \cf6 Ethernet_Handle\cf4  handleApplication,\cf0\par
\cf4         \cf6 Ethernet_Pkt_Desc\cf4  *pPacket)\cf0\par
\cf4\{\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Once the packet is sent, reuse the packet memory to avoid\cf0\par
\cf4     \cf1 // memory leaks. Call this interrupt handler function which will take care\cf0\par
\cf4     \cf1 // of freeing the memory used by the packet descriptor.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     lwIPEthernetIntHandler(pPacket);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Increment the book-keeping counter.\cf0\par
\cf4     \cf1 //\cf0\par
\cf3\highlight8\b #ifdef\cf4\b0  ETHERNET_DEBUG\cf0\highlight0\par
\cf4\highlight8     releaseTxCount++;\cf0\highlight0\par
\cf3\highlight8\b #endif\cf0\highlight0\b0\par
\cf4\}\cf0\par
\par
\cf6 Ethernet_Pkt_Desc\cf4  *\b Ethernet_performPopOnPacketQueueCustom\b0 (\cf0\par
\cf4             \cf6 Ethernet_PKT_Queue_T\cf4  *pktQueuePtr)\cf0\par
\cf4\{\cf0\par
\cf4     \cf6 Ethernet_Pkt_Desc\cf4  *pktDescHdrPtr;\cf0\par
\par
\cf4     pktDescHdrPtr = pktQueuePtr->\cf9 head\cf4 ;\cf0\par
\par
\cf4     \cf3\b if\cf4\b0 (0U != pktDescHdrPtr)\cf0\par
\cf4     \{\cf0\par
\cf4         pktQueuePtr->\cf9 head\cf4  = pktDescHdrPtr->\cf9 nextPacketDesc\cf4 ;\cf0\par
\cf4         pktQueuePtr->\cf9 count\cf4 --;\cf0\par
\cf4     \}\cf0\par
\par
\cf4     \cf3\b return\cf4\b0 (pktDescHdrPtr);\cf0\par
\cf4\}\cf0\par
\cf3\b void\cf4\b0  \b Ethernet_performPushOnPacketQueueCustom\b0 (\cf0\par
\cf4         \cf6 Ethernet_PKT_Queue_T\cf4  *pktQueuePtr,\cf0\par
\cf4         \cf6 Ethernet_Pkt_Desc\cf4  *pktDescHdrPtr)\cf0\par
\cf4\{\cf0\par
\cf4     pktDescHdrPtr->\cf9 nextPacketDesc\cf4  = 0U;\cf0\par
\par
\cf4     \cf3\b if\cf4\b0 (0U == pktQueuePtr->\cf9 head\cf4 )\cf0\par
\cf4     \{\cf0\par
\cf4         \cf1 //\cf0\par
\cf4         \cf1 // Queue is empty - Initialize it with this one packet\cf0\par
\cf4         \cf1 //\cf0\par
\cf4         pktQueuePtr->\cf9 head\cf4  = pktDescHdrPtr;\cf0\par
\cf4         pktQueuePtr->\cf9 tail\cf4  = pktDescHdrPtr;\cf0\par
\cf4     \}\cf0\par
\cf4     \cf3\b else\cf0\b0\par
\cf4     \{\cf0\par
\cf4         \cf1 //\cf0\par
\cf4         \cf1 // Queue is not empty - Push onto END\cf0\par
\cf4         \cf1 //\cf0\par
\cf4         pktQueuePtr->\cf9 tail\cf4 ->\cf9 nextPacketDesc\cf4  = pktDescHdrPtr;\cf0\par
\cf4         pktQueuePtr->\cf9 tail\cf4         = pktDescHdrPtr;\cf0\par
\cf4     \}\cf0\par
\cf4     pktQueuePtr->\cf9 count\cf4 ++;\cf0\par
\cf4\}\cf0\par
\cf3\b void\cf4\b0  \b Ethernet_setMACConfigurationCustom\b0 (\cf6 uint32_t\cf4  base, \cf6 uint32_t\cf4  flags)\cf0\par
\cf4\{\cf0\par
\cf4     HWREG(base + ETHERNET_O_MAC_CONFIGURATION) |= flags;\cf0\par
\cf4\}\cf0\par
\cf3\b void\cf4\b0  \b Ethernet_clearMACConfigurationCustom\b0 (\cf6 uint32_t\cf4  base, \cf6 uint32_t\cf4  flags)\cf0\par
\cf4\{\cf0\par
\cf4     HWREG(base + ETHERNET_O_MAC_CONFIGURATION) &= ~flags;\cf0\par
\par
\cf4\}\cf0\par
\par
\cf4 interrupt \cf3\b void\cf4\b0  \b Ethernet_genericISRCustom\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf4     genericISRCustomcount++;\cf0\par
\cf4     \cf6 Ethernet_RxChDesc\cf4  *rxChan;\cf0\par
\cf4     \cf6\ul Ethernet_TxChDesc\cf4  *txChan;\cf0\ulnone\par
\cf4     \cf6\ul Ethernet_HW_descriptor\cf4     *descPtr;\cf0\ulnone\par
\cf4     \cf6\ul Ethernet_HW_descriptor\cf4     *tailPtr;\cf0\ulnone\par
\cf4     \cf6 uint16_t\cf4  i=0;\cf0\par
\cf4     Ethernet_clearMACConfigurationCustom(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,ETHERNET_MAC_CONFIGURATION_RE);\cf0\par
\cf4     Ethernet_clearMACConfigurationCustom(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,ETHERNET_MAC_CONFIGURATION_TE);\cf0\par
\cf4     \cf3\b for\cf4\b0 (i = 0U;i < Ethernet_device_struct.\cf9 initConfig\cf4 .\cf9 numChannels\cf4 ;i++)\cf0\par
\cf4      \{\cf0\par
\cf4          \cf7\b Ethernet_disableRxDMAReception\cf4\b0 (\cf0\par
\cf4                Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,\cf0\par
\cf4                i);\cf0\par
\cf4      \}\cf0\par
\cf4     \cf3\b if\cf4\b0 (((ETHERNET_DMA_CH0_STATUS_AIS |\cf0\par
\cf4                          ETHERNET_DMA_CH0_STATUS_RBU) ==\cf0\par
\cf4                        (HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  +\cf0\par
\cf4                               ETHERNET_O_DMA_CH0_STATUS) &\cf0\par
\cf4                               (\cf6 uint32_t\cf4 )(ETHERNET_DMA_CH0_STATUS_AIS |\cf0\par
\cf4                                          ETHERNET_DMA_CH0_STATUS_RBU))) ||\cf0\par
\cf4           (ETHERNET_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS) ==\cf0\par
\cf4                                    (HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  +\cf0\par
\cf4                                           ETHERNET_O_MTL_Q0_INTERRUPT_CONTROL_STATUS) &\cf0\par
\cf4                                           (\cf6 uint32_t\cf4 )(ETHERNET_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS\cf0\par
\cf4                                                      )))\cf0\par
\cf4       \{\cf0\par
\cf4           \cf3\b if\cf4\b0 ((ETHERNET_DMA_CH0_STATUS_AIS |\cf0\par
\cf4                              ETHERNET_DMA_CH0_STATUS_RBU) ==\cf0\par
\cf4                            (HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  +\cf0\par
\cf4                                   ETHERNET_O_DMA_CH0_STATUS) &\cf0\par
\cf4                                   (\cf6 uint32_t\cf4 )(ETHERNET_DMA_CH0_STATUS_AIS |\cf0\par
\cf4                                              ETHERNET_DMA_CH0_STATUS_RBU)))\cf0\par
\cf4           \{\cf0\par
\cf4           genericISRCustomRBUcount++;\cf0\par
\cf4           \}\cf0\par
\cf4           \cf3\b if\cf4\b0 ((ETHERNET_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS) ==\cf0\par
\cf4                   (HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  +\cf0\par
\cf4                          ETHERNET_O_MTL_Q0_INTERRUPT_CONTROL_STATUS) &\cf0\par
\cf4                          (\cf6 uint32_t\cf4 )(ETHERNET_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS\cf0\par
\cf4                                     )))\cf0\par
\cf4           \{\cf0\par
\cf4               genericISRCustomROVcount++;\cf0\par
\cf4               \cf7\b Ethernet_enableMTLInterrupt\cf4\b0 (Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,0,\cf0\par
\cf4                                           ETHERNET_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOVFIS);\cf0\par
\cf4           \}\cf0\par
\par
\cf4         \cf1 /*\cf0\par
\cf1              * Clear the AIS and RBU status bit. These MUST be\cf0\par
\cf1              * cleared together!\cf0\par
\cf1              */\cf0\par
\cf4             \cf7\b Ethernet_clearDMAChannelInterrupt\cf4\b0 (\cf0\par
\cf4                     Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,\cf0\par
\cf4                     ETHERNET_DMA_CHANNEL_NUM_0,\cf0\par
\cf4                     ETHERNET_DMA_CH0_STATUS_AIS |\cf0\par
\cf4                     ETHERNET_DMA_CH0_STATUS_RBU);\cf0\par
\par
\cf4             \cf1 /*\cf0\par
\cf1            *Recover from Receive Buffer Unavailable (and hung DMA)\cf0\par
\cf1          *\cf0\par
\cf1          * All descriptor buffers are owned by the application, and\cf0\par
\cf1          * in result the DMA cannot transfer incoming frames to the\cf0\par
\cf1          * buffers (RBU condition). DMA has also entered suspend\cf0\par
\cf1          * mode at this point, too.\cf0\par
\cf1          *\cf0\par
\cf1          * Drain the RX queues\cf0\par
\cf1          */\cf0\par
\par
\cf4             \cf1 /* Upon RBU error, discard all previously received packets */\cf0\par
\cf4             \cf3\b if\cf4\b0 (Ethernet_device_struct.\cf9 initConfig\cf4 .\cf9 pfcbDeletePackets\cf4  != NULL)\cf0\par
\cf4                 (*Ethernet_device_struct.\cf9 initConfig\cf4 .\cf9 pfcbDeletePackets\cf4 )();\cf0\par
\par
\cf4             rxChan =\cf0\par
\cf4                &Ethernet_device_struct.\cf9 dmaObj\cf4 .\cf9 rxDma\cf4 [ETHERNET_DMA_CHANNEL_NUM_0];\cf0\par
\cf4             txChan=\cf0\par
\cf4                &Ethernet_device_struct.\cf9 dmaObj\cf4 .\cf9 txDma\cf4 [ETHERNET_DMA_CHANNEL_NUM_0];\cf0\par
\par
\cf4     \cf1 /*\cf0\par
\cf1      * Need to disable multiple interrupts, so protect the code to do so within\cf0\par
\cf1      * a global disable block (to prevent getting interrupted in between)\cf0\par
\cf1      */\cf0\par
\par
\cf4             \cf3\b if\cf4\b0 (NULL!= Ethernet_device_struct.\cf9 ptrPlatformInterruptDisable\cf4 )\cf0\par
\cf4             \{\cf0\par
\cf4                 (*Ethernet_device_struct.\cf9 ptrPlatformInterruptDisable\cf4 )(\cf0\par
\cf4                     Ethernet_device_struct.\cf9 interruptNum\cf4 [\cf0\par
\cf4                         ETHERNET_RX_INTR_CH0 + rxChan->\cf9 chInfo\cf4 ->\cf9 chNum\cf4 ]);\cf0\par
\par
\cf4                 (*Ethernet_device_struct.\cf9 ptrPlatformInterruptDisable\cf4 )(\cf0\par
\cf4                     Ethernet_device_struct.\cf9 interruptNum\cf4 [\cf0\par
\cf4                         ETHERNET_GENERIC_INTERRUPT]);\cf0\par
\cf4             \}\cf0\par
\cf4             \cf1 /* verify we have full capacity in the descriptor queue */\cf0\par
\cf4             \cf3\b if\cf4\b0 (rxChan->\cf9 descQueue\cf4 .\cf9 count\cf4  < rxChan->\cf9 descMax\cf4 ) \{\cf0\par
\cf4               \cf1 /* The queue is not at full capacity due to OOM errors.\cf0\par
\cf1               Try to fill it again */\cf0\par
\cf4                 \cf7\b Ethernet_addPacketsIntoRxQueue\cf4\b0 (rxChan);\cf0\par
\cf4             \}\cf0\par
\cf4             \cf7\b Ethernet_initRxChannel\cf4\b0 (\cf0\par
\cf4                     &Ethernet_device_struct.\cf9 initConfig\cf4 .\cf9 chInfo\cf4 [ETHERNET_CH_DIR_RX][0]);\cf0\par
\par
\cf4             \cf7\b Ethernet_writeRxDescTailPointer\cf4\b0 (\cf0\par
\cf4                 Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,\cf0\par
\cf4                 0,\cf0\par
\cf4                 (&Ethernet_device_struct.\cf9 rxDesc\cf4 [\cf0\par
\cf4                  ((\cf6 uint32_t\cf4 )ETHERNET_DESCRIPTORS_NUM_RX_PER_CHANNEL) *\cf0\par
\cf4                   (0 + (\cf6 uint32_t\cf4 )1U)]));\cf0\par
\par
\cf4             \cf3\b if\cf4\b0 (NULL!= Ethernet_device_struct.\cf9 ptrPlatformInterruptEnable\cf4 )\cf0\par
\cf4             \{\cf0\par
\cf4                 (*Ethernet_device_struct.\cf9 ptrPlatformInterruptEnable\cf4 )(\cf0\par
\cf4                     Ethernet_device_struct.\cf9 interruptNum\cf4 [\cf0\par
\cf4                         ETHERNET_RX_INTR_CH0 + rxChan->\cf9 chInfo\cf4 ->\cf9 chNum\cf4 ]);\cf0\par
\cf4                 (*Ethernet_device_struct.\cf9 ptrPlatformInterruptEnable\cf4 )(\cf0\par
\cf4                     Ethernet_device_struct.\cf9 interruptNum\cf4 [\cf0\par
\cf4                         ETHERNET_GENERIC_INTERRUPT]);\cf0\par
\cf4             \}\cf0\par
\par
\par
\cf4     \}\cf0\par
\cf4     \cf3\b if\cf4\b0 (0U != (HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  +\cf0\par
\cf4                                  ETHERNET_O_DMA_CH0_STATUS) &\cf0\par
\cf4                            (\cf6 uint32_t\cf4 ) ETHERNET_DMA_CH0_STATUS_RI))\cf0\par
\cf4     \{\cf0\par
\cf4         genericISRCustomRIcount++;\cf0\par
\cf4         \cf7\b Ethernet_clearDMAChannelInterrupt\cf4\b0 (\cf0\par
\cf4                         Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,\cf0\par
\cf4                         ETHERNET_DMA_CHANNEL_NUM_0,\cf0\par
\cf4                         ETHERNET_DMA_CH0_STATUS_NIS | ETHERNET_DMA_CH0_STATUS_RI);\cf0\par
\cf4     \}\cf0\par
\par
\cf4     \cf3\b for\cf4\b0 (i = 0U;i < Ethernet_device_struct.\cf9 initConfig\cf4 .\cf9 numChannels\cf4 ;i++)\cf0\par
\cf4      \{\cf0\par
\cf4          \cf7\b Ethernet_enableRxDMAReception\cf4\b0 (\cf0\par
\cf4                Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,\cf0\par
\cf4                i);\cf0\par
\cf4      \}\cf0\par
\cf4     Ethernet_setMACConfigurationCustom(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,ETHERNET_MAC_CONFIGURATION_RE);\cf0\par
\cf4     Ethernet_setMACConfigurationCustom(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,ETHERNET_MAC_CONFIGURATION_TE);\cf0\par
\cf4\}\cf0\par
\par
\cf3\b void\cf0\b0\par
\cf4\b Ethernet_init\b0 (\cf3\b const\cf4\b0  \cf3\b unsigned\cf4\b0  \cf3\b char\cf4\b0  *mac)\cf0\par
\cf4\{\cf0\par
\cf4     \cf6 Ethernet_InitInterfaceConfig\cf4  initInterfaceConfig;\cf0\par
\cf4     \cf6 uint32_t\cf4  macLower;\cf0\par
\cf4     \cf6 uint32_t\cf4  macHigher;\cf0\par
\cf4     \cf6 uint8_t\cf4  *temp;\cf0\par
\par
\cf4     initInterfaceConfig.\cf9 ssbase\cf4  = EMAC_SS_BASE;\cf0\par
\cf4     initInterfaceConfig.\cf9 enet_base\cf4  = EMAC_BASE;\cf0\par
\cf4     initInterfaceConfig.\cf9 phyMode\cf4  = \cf9\i ETHERNET_SS_PHY_INTF_SEL_MII\cf4\i0 ;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Assign SoC specific functions for Enabling,Disabling interrupts\cf0\par
\cf4     \cf1 // and for enabling the Peripheral at system level\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     initInterfaceConfig.\cf9 ptrPlatformInterruptDisable\cf4  =\cf0\par
\cf4                                                     &\cf7\b Platform_disableInterrupt\cf4\b0 ;\cf0\par
\cf4     initInterfaceConfig.\cf9 ptrPlatformInterruptEnable\cf4  =\cf0\par
\cf4                                                      &\cf7\b Platform_enableInterrupt\cf4\b0 ;\cf0\par
\cf4     initInterfaceConfig.\cf9 ptrPlatformPeripheralEnable\cf4  =\cf0\par
\cf4                                                     &\cf7\b Platform_enablePeripheral\cf4\b0 ;\cf0\par
\cf4     initInterfaceConfig.\cf9 ptrPlatformPeripheralReset\cf4  =\cf0\par
\cf4                                                      &\cf7\b Platform_resetPeripheral\cf4\b0 ;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Assign the peripheral number at the SoC\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     initInterfaceConfig.\cf9 peripheralNum\cf4  = \cf9\i SYSCTL_PERIPH_CLK_ENET\cf4\i0 ;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Assign the default SoC specific interrupt numbers of Ethernet interrupts\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     initInterfaceConfig.\cf9 interruptNum\cf4 [0] = INT_EMAC;\cf0\par
\cf4     initInterfaceConfig.\cf9 interruptNum\cf4 [1] = INT_EMAC_TX0;\cf0\par
\cf4     initInterfaceConfig.\cf9 interruptNum\cf4 [2] = INT_EMAC_TX1;\cf0\par
\cf4     initInterfaceConfig.\cf9 interruptNum\cf4 [3] = INT_EMAC_RX0;\cf0\par
\cf4     initInterfaceConfig.\cf9 interruptNum\cf4 [4] = INT_EMAC_RX1;\cf0\par
\par
\cf4     pInitCfg = \cf7\b Ethernet_initInterface\cf4\b0 (initInterfaceConfig);\cf0\par
\par
\cf4     \cf7\b Ethernet_getInitConfig\cf4\b0 (pInitCfg);\cf0\par
\cf4     pInitCfg->\cf9 dmaMode\cf4 .\cf9 InterruptMode\cf4  = ETHERNET_DMA_MODE_INTM_MODE2;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Assign the \ul callbacks\ulnone  for Getting packet buffer when needed\cf0\par
\cf4     \cf1 // Releasing the TxPacketBuffer on Transmit interrupt \ul callbacks\cf0\ulnone\par
\cf4     \cf1 // Receive packet callback on Receive packet completion interrupt\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     pInitCfg->\cf9 pfcbRxPacket\cf4  = &Ethernet_receivePacketCallbackCustom;\cf0\par
\cf4     pInitCfg->\cf9 pfcbGetPacket\cf4  = &\cf7\b Ethernet_getPacketBuffer\cf4\b0 ;    \cf1 //custom\cf0\par
\cf4     pInitCfg->\cf9 pfcbFreePacket\cf4  = &Ethernet_releaseTxPacketBufferCustom;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 //Assign the Buffer to be used by the Low level driver for receiving\cf0\par
\cf4     \cf1 //Packets. This should be accessible by the Ethernet DMA\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     pInitCfg->\cf9 rxBuffer\cf4  = Ethernet_rxBuffer;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // The Application handle is not used by this application\cf0\par
\cf4     \cf1 // Hence using a dummy value of 1\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b Ethernet_getHandle\cf4\b0 ((\cf6 Ethernet_Handle\cf4 )1, pInitCfg , &emac_handle);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Disable transmit buffer unavailable and normal interrupt which\cf0\par
\cf4     \cf1 // are enabled by default in Ethernet_getHandle.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b Ethernet_disableDmaInterrupt\cf4\b0 (Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,\cf0\par
\cf4                                  0, (ETHERNET_DMA_CH0_INTERRUPT_ENABLE_TBUE |\cf0\par
\cf4                                      ETHERNET_DMA_CH0_INTERRUPT_ENABLE_NIE));\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Enable the MTL interrupt to service the receive FIFO overflow\cf0\par
\cf4     \cf1 // condition in the Ethernet module.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b Ethernet_enableMTLInterrupt\cf4\b0 (Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,0,\cf0\par
\cf4                                 ETHERNET_MTL_Q0_INTERRUPT_CONTROL_STATUS_RXOIE);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Disable the MAC Management counter interrupts as they are not used\cf0\par
\cf4     \cf1 // in this application.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  + ETHERNET_O_MMC_RX_INTERRUPT_MASK) = 0xFFFFFFFF;\cf0\par
\cf4     HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  + ETHERNET_O_MMC_IPC_RX_INTERRUPT_MASK) = 0xFFFFFFFF;\cf0\par
\cf4     HWREG(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4  + ETHERNET_O_MMC_TX_INTERRUPT_MASK) = 0xFFFFFFFF;\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 //Do global Interrupt Enable\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     (\cf3\b void\cf4\b0 )Interrupt_enableInProcessor();\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 //Assign default ISRs\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b Interrupt_registerHandler\cf4\b0 (INT_EMAC_TX0, Ethernet_transmitISR);\cf0\par
\cf4     \cf7\b Interrupt_registerHandler\cf4\b0 (INT_EMAC_RX0, Ethernet_receiveISR);\cf0\par
\cf4     \cf7\b Interrupt_registerHandler\cf4\b0 (INT_EMAC, Ethernet_genericISRCustom);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Convert the \ul mac\ulnone  address string into the 32/16 split variables format\cf0\par
\cf4     \cf1 // that is required by the driver to program into hardware registers.\cf0\par
\cf4     \cf1 // Note: This step is done after the Ethernet_getHandle function because\cf0\par
\cf4     \cf1 //       a dummy MAC address is programmed in that function.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     temp = (\cf6 uint8_t\cf4  *)&macLower;\cf0\par
\cf4     temp[0] = mac[0];\cf0\par
\cf4     temp[1] = mac[1];\cf0\par
\cf4     temp[2] = mac[2];\cf0\par
\cf4     temp[3] = mac[3];\cf0\par
\par
\cf4     temp = (\cf6 uint8_t\cf4  *)&macHigher;\cf0\par
\cf4     temp[0] = mac[4];\cf0\par
\cf4     temp[1] = mac[5];\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Program the \ul unicast\ulnone  \ul mac\ulnone  address.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b Ethernet_setMACAddr\cf4\b0 (EMAC_BASE,\cf0\par
\cf4                         0,\cf0\par
\cf4                         macHigher,\cf0\par
\cf4                         macLower,\cf0\par
\cf4                         \cf9\i ETHERNET_CHANNEL_0\cf4\i0 );\cf0\par
\par
\cf4     Ethernet_clearMACConfigurationCustom(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,ETHERNET_MAC_CONFIGURATION_RE);\cf0\par
\cf4     Ethernet_setMACConfigurationCustom(Ethernet_device_struct.\cf9 baseAddresses\cf4 .\cf9 enet_base\cf4 ,ETHERNET_MAC_CONFIGURATION_RE);\cf0\par
\cf4\}\cf0\par
\par
\par
\par
\par
\cf3\b void\cf4\b0  \b udp_rx_callback\b0 (\cf3\b void\cf4\b0  *arg, \cf3\b struct\cf4\b0  \cf6 udp_pcb\cf4  *upcb, \cf3\b struct\cf4\b0  \cf6 pbuf\cf4  *p,\cf0\par
\cf4                \cf3\ul\b struct\cf4\b0  ip_addr *addr, \cf6 u16_t\cf4  port)\cf0\ulnone\par
\par
\cf4\{\cf0\par
\cf4     \cf3\b char\cf4\b0  *cad_rx;\cf0\par
\cf4     \cf6 uint16_t\cf4  long_actual = 0;\cf0\par
\cf4     \cf6 uint16_t\cf4  long_UDP_complete = 0;\cf0\par
\cf4     \cf6 uint16_t\cf4  long_total = 0;\cf0\par
\cf4     \cf6 uint8_t\cf4  cnt_lee = 0;\cf0\par
\par
\cf4     httpLEDToggle();\cf0\par
\par
\par
\cf4     \cf7\b memset\cf4\b0 (buf_rx, 0x00, 50);\cf0\par
\par
\par
\cf4     long_total = p->\cf9 tot_len\cf4 ;\cf0\par
\par
\cf4     cont_rx_udp++;\cf0\par
\par
\par
\par
\cf4     \cf3\b while\cf4\b0  ((long_UDP_complete < long_total)\cf0\par
\cf4             && (long_UDP_complete < 1800) || (cnt_lee == 0))\cf0\par
\cf4     \{\cf0\par
\cf4         cnt_lee++;\cf0\par
\cf4         long_actual = p->\cf9 len\cf4 ;\cf0\par
\par
\cf4         cad_rx = p->\cf9 payload\cf4 ;\cf0\par
\par
\cf4         \cf3\b int\cf4\b0  i = 0;\cf0\par
\cf4         \cf3\b for\cf4\b0  (i = 0; i < long_actual; i++)\cf0\par
\cf4         \{\cf0\par
\par
\cf4             buf_rx[0 + i + long_UDP_complete] = *cad_rx++;\cf0\par
\cf4         \}\cf0\par
\cf4         long_UDP_complete = long_actual + long_UDP_complete;\cf0\par
\cf4         buf_rx[long_UDP_complete + 1] = \cf5 '\\n'\cf4 ;\cf0\par
\par
\cf4         \cf3\b if\cf4\b0  (long_UDP_complete == long_total)\cf0\par
\cf4         \{\cf0\par
\cf4             \cf7\b pbuf_free\cf4\b0 (p); \cf1 /* don't leak the \ul pbuf\ulnone !*/\cf0\par
\cf4         \}\cf0\par
\cf4         \cf3\b else\cf0\b0\par
\cf4         \{\cf0\par
\cf4             \cf3\b if\cf4\b0  ( p->\cf9 next\cf4  != NULL)\cf0\par
\cf4             p = p->\cf9 next\cf4 ;\cf0\par
\cf4             \cf1 //  pbuf_free(a);                                   /* don't leak the \ul pbuf\ulnone !*/\cf0\par
\cf4         \}\cf0\par
\par
\cf4         \cf3\b if\cf4\b0  ((buf_rx[0] == \cf5 'S'\cf4 ) && (buf_rx[1] == \cf5 'T'\cf4 ) && (buf_rx[2] == \cf5 'O'\cf4 ) && (buf_rx[3] == \cf5 'P'\cf4 ))\cf0\par
\cf4         \{                    \cf1 //Disconnect\cf0\par
\cf4                              \cf1 //udp_disconnect(\ul upcb\ulnone );\cf0\par
\par
\cf4             Connected_udp_28000 = false;\cf0\par
\cf4             cnt_Connected_udp_28000 = 0;\cf0\par
\cf4         \}\cf0\par
\cf4         \cf3\b else\cf4\b0  \cf3\b if\cf4\b0  ((buf_rx[0] == \cf5 'S'\cf4 ) && (buf_rx[1] == \cf5 'T'\cf4 ) && (buf_rx[2] == \cf5 'A'\cf4 ) && (buf_rx[3] == \cf5 'R'\cf4 ) && (buf_rx[4] == \cf5 'T'\cf4 ))\cf0\par
\cf4         \{                \cf1 //Connect\cf0\par
\par
\cf4                     Connected_udp_28000 = true;\cf0\par
\cf4                     cnt_Connected_udp_28000 = 0;\cf0\par
\par
\cf4                    \cf1 /* process the \ul payload\ulnone  in p->\ul payload\ulnone  */\cf0\par
\cf4                    \cf7\ul\b udp_connect\cf4\b0 (upcb, addr, port); \cf1 /* connect to the remote host */\cf0\ulnone\par
\par
\cf4         \}\cf0\par
\cf4     \}\cf0\par
\par
\cf4     \cf7\b pbuf_free\cf4\b0 (p);\cf0\par
\par
\cf4     \cf3\b if\cf4\b0  (!Connected_udp_28000)\cf0\par
\cf4     \{\cf0\par
\cf4         \cf7\b udp_disconnect\cf4\b0 (upcb);\cf0\par
\cf4     \}\cf0\par
\par
\cf4\}\cf0\par
\par
\cf1 /* UDP initialization ......................................................*/\cf0\par
\cf3\b void\cf4\b0  \b my_udp_init\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\par
\cf4     g_upcb = \cf7\b udp_new\cf4\b0 ();\cf0\par
\cf4     \cf7\b udp_bind\cf4\b0 (g_upcb, IP_ADDR_ANY, 28000);\cf0\par
\cf4     \cf7\ul\b udp_recv\cf4\b0 (g_upcb, &udp_rx_callback, (\cf3\b void\cf4\b0 *) 0);\cf0\ulnone\par
\par
\par
\cf4\}\cf0\par
\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // This example demonstrates the use of the Ethernet Controller.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\par
\cf3\b unsigned\cf4\b0  \cf3\b long\cf4\b0  IPAddr =  0xC0A80004; \cf1 // 0xC0A80004; //192.168.0.4\cf0\par
\cf3\b unsigned\cf4\b0  \cf3\b long\cf4\b0  NetMask = 0xFFFFFF00;\cf0\par
\cf3\b unsigned\cf4\b0  \cf3\b long\cf4\b0  GWAddr = 0xC0A8000A;\cf0\par
\par
\cf3\b #define\cf4\b0  IPC_DATA_SIZE 100 \cf1 // \ul Taille\ulnone  \ul des\ulnone  \ul donn\f1\'e9es\ulnone\f0  \ul transf\f1\'e9r\'e9es\ulnone\f0  via IPC\cf0\par
\cf3\b #define\cf4\b0  DATALOAD 500\cf0\par
\cf6 uint32_t\cf4  buf_kx[DATALOAD];\cf0\par
\par
\cf3\b int\cf0\b0\par
\cf4\b main\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf4     \cf3\b unsigned\cf4\b0  \cf3\b long\cf4\b0  ulUser0, ulUser1;\cf0\par
\cf4     \cf3\b unsigned\cf4\b0  \cf3\b char\cf4\b0  pucMACArray[8];\cf0\par
\par
\cf4     \cf3\b int\cf4\b0  i=0;\cf0\par
\par
\par
\cf4     \cf1 //  ////////////////////////////////////////\cf0\par
\cf4     \cf1 // Initializing the CM. Loading the required functions to SRAM.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     CM_init();\cf0\par
\par
\cf4     SYSTICK_setPeriod(systickPeriodValue);\cf0\par
\cf4     SYSTICK_enableCounter();\cf0\par
\cf4     SYSTICK_registerInterruptHandler(SysTickIntHandler);\cf0\par
\cf4     SYSTICK_enableInterrupt();\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Enable processor interrupts.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     Interrupt_enableInProcessor();\cf0\par
\par
\cf4     \cf1 // Set user/company specific MAC \ul octets\cf0\ulnone\par
\cf4     \cf1 // (for this code we are using A8-63-F2-00-00-80)\cf0\par
\cf4     \cf1 // 0x00 MACOCT3 MACOCT2 MACOCT1\cf0\par
\cf4     ulUser0 = 0x00F263A8;\cf0\par
\par
\cf4     \cf1 // 0x00 MACOCT6 MACOCT5 MACOCT4\cf0\par
\cf4     ulUser1 = 0x00800000;\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Convert the 24/24 split MAC address from NV ram into a 32/16 split MAC\cf0\par
\cf4     \cf1 // address needed to program the hardware registers, then program the MAC\cf0\par
\cf4     \cf1 // address into the Ethernet Controller registers.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     pucMACArray[0] = ((ulUser0 >>  0) & 0xff);\cf0\par
\cf4     pucMACArray[1] = ((ulUser0 >>  8) & 0xff);\cf0\par
\cf4     pucMACArray[2] = ((ulUser0 >> 16) & 0xff);\cf0\par
\cf4     pucMACArray[3] = ((ulUser1 >>  0) & 0xff);\cf0\par
\cf4     pucMACArray[4] = ((ulUser1 >>  8) & 0xff);\cf0\par
\cf4     pucMACArray[5] = ((ulUser1 >> 16) & 0xff);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Initialize \ul ethernet\ulnone  module.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     Ethernet_init(pucMACArray);\cf0\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // \ul Initialze\ulnone  the lwIP library, using DHCP.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf7\b lwIPInit\cf4\b0 (0, pucMACArray, IPAddr, NetMask, GWAddr, IPADDR_USE_STATIC);\cf0\par
\par
\cf4     \cf1 // Initialize the UDP server\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     my_udp_init();\cf0\par
\par
\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Loop forever. All the work is done in interrupt handlers.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4      \cf6 uint32_t\cf4  cnt_FFT = 0;\cf0\par
\par
\cf4     \cf7\b Interrupt_setPriority\cf4\b0 (INT_EMAC_TX0, 2);\cf0\par
\cf4     \cf7\b Interrupt_setPriority\cf4\b0 (INT_EMAC_RX0, 1);\cf0\par
\cf4     \cf7\b Interrupt_enable\cf4\b0 (INT_EMAC_TX0);\cf0\par
\cf4     \cf7\b Interrupt_enable\cf4\b0 (INT_EMAC_RX0);\cf0\par
\cf4     \cf7\b Interrupt_enable\cf4\b0 (INT_EMAC);\cf0\par
\par
\cf4     IPC_init(\cf9\i IPC_CM_L_CPU1_R\cf4\i0 );\cf0\par
\par
\cf4     IPC_sync(\cf9\i IPC_CM_L_CPU1_R\cf4\i0 , IPC_FLAG31);\cf0\par
\par
\cf4     \cf3\b volatile\cf4\b0  \cf3\b int\cf4\b0  cnt_total_loop=0;\cf0\par
\cf4     \cf3\b volatile\cf4\b0  \cf3\b int\cf4\b0  cnt_total_mqtt_pub=0;\cf0\par
\cf4     \cf3\b int\cf4\b0  j=0 ;\cf0\par
\par
\cf4     \cf3\b while\cf4\b0  (1)\cf0\par
\cf4     \{\cf0\par
\cf4         \cf3\b if\cf4\b0  (IPC_isFlagBusyRtoL(\cf9\i IPC_CM_L_CPU1_R\cf4\i0 , IPC_FLAG0))\cf0\par
\cf4             \{\cf0\par
\cf4                 \cf6 uint32_t\cf4  cmd, addr, data;\cf0\par
\par
\cf4                 \cf7\b IPC_readCommand\cf4\b0 (\cf9\i IPC_CM_L_CPU1_R\cf4\i0 , IPC_FLAG0,IPC_ADDR_CORRECTION_DISABLE, &cmd, &addr, &data);\cf0\par
\cf4                 \cf3\b if\cf4\b0  (cmd == IPC_CMD_READ_MEM)\cf0\par
\cf4                 \{\cf0\par
\par
\cf4                  \cf1 /*   uint32_t* source = (uint32_t*)\ul addr\ulnone ;\cf0\par
\cf1                    \ul memcpy\ulnone (buf_kx, source, DATALOAD * \ul sizeof\ulnone (buf_kx));*/\cf0\par
\cf4                     \cf7\b memcpy\cf4\b0 (&buf_kx[j], &addr,\cf3\b sizeof\cf4\b0 (data));\cf0\par
\cf4                     j++;\cf0\par
\cf4                 \}\cf0\par
\par
\cf4                IPC_ackFlagRtoL(\cf9\i IPC_CM_L_CPU1_R\cf4\i0 , IPC_FLAG0);\cf0\par
\par
\par
\cf4                 \cf3\b if\cf4\b0 (j>=DATALOAD)\{j=0;\}\cf0\par
\cf4             \}\cf0\par
\par
\par
\cf4         cnt_total_loop++;\cf0\par
\par
\cf4         \cf3\b if\cf4\b0  (Connected_udp_28000)\cf0\par
\cf4         \{\cf0\par
\cf4             \cf1 //UDP TX block\cf0\par
\par
\cf4             \cf3\b if\cf4\b0  (flag_TX_frame_UDP)\cf0\par
\cf4             \{\cf0\par
\cf4                 cnt_FFT++;\cf0\par
\par
\cf4                 \cf1 //flag_TX_frame_UDP = false;\cf0\par
\par
\cf4                 \cf1 /////////////////////////////////////////////\cf0\par
\cf4                 \cf3\b for\cf4\b0  (i = 0; i < PAYLOAD; i++)\cf0\par
\cf4                 \{\cf0\par
\cf4                     \cf3\b if\cf4\b0 (i < buf_tx_start_msg_count)\cf0\par
\cf4                     \{\cf0\par
\cf4                         buf_tx[i] = (\cf6 uint8_t\cf4 )buf_tx_start_msg[i];\cf0\par
\cf4                     \}\cf0\par
\cf4                     \cf3\b else\cf4\b0  \cf3\b if\cf4\b0  (i - buf_tx_start_msg_count < \cf3\b sizeof\cf4\b0 (buf_kx)) \{\cf0\par
\cf4                       buf_tx[i] = buf_kx[i - buf_tx_start_msg_count];\cf0\par
\cf4                    \} \cf3\b else\cf4\b0  \{\cf0\par
\cf4                    buf_tx[i] = 0; \cf1 // \ul Valeur\ulnone  par \ul d\f1\'e9faut\ulnone\f0  \ul si\ulnone  \ul les\ulnone  \ul donn\f1\'e9es\ulnone\f0  \ul re\f1\'e7ues\ulnone\f0  \ul sont\ulnone  plus \ul petites\ulnone  \ul que\ulnone  \ul pr\f1\'e9vu\cf0\ulnone\f0\par
\cf4                                                                      \}\cf0\par
\par
\cf4                 \}\cf0\par
\par
\cf4                 \cf1 ////////////////////////////////////////////\cf0\par
\par
\cf4                 pbuf1_tx = \cf7\b pbuf_alloc\cf4\b0 (\cf9\i PBUF_TRANSPORT\cf4\i0 , PAYLOAD, \cf9\i PBUF_RAM\cf4\i0 );\cf0\par
\cf4                 \cf3\b if\cf4\b0  (pbuf1_tx!= NULL)\cf0\par
\cf4                 \{\cf0\par
\cf4                 pbuf1_tx->\cf9 payload\cf4  = (\cf3\b void\cf4\b0 *) buf_tx;\cf0\par
\cf4                 pbuf1_tx->\cf9 tot_len\cf4  = PAYLOAD;  \cf1 //17        // long_UDP_complete+4;\cf0\par
\cf4                 pbuf1_tx->\cf9 len\cf4  = PAYLOAD;   \cf1 //17       // long_UDP_complete+4;\cf0\par
\par
\cf4                     \cf7\b udp_send\cf4\b0 (g_upcb, pbuf1_tx);\cf0\par
\par
\cf4                 \}\cf0\par
\par
\par
\cf4                 cnt_Connected_udp_28000++;\cf0\par
\par
\par
\cf4                 \cf3\b if\cf4\b0  (pbuf1_tx!= NULL)\cf0\par
\cf4                 \cf7\b pbuf_free\cf4\b0 (pbuf1_tx);\cf0\par
\par
\cf4             \}\cf0\par
\par
\cf4         \}\cf0\par
\par
\par
\cf4         \cf7\b SysCtl_delay\cf4\b0 (6000000);\cf1 //\ul aprox\ulnone  1 \ul sec\cf0\ulnone\par
\par
\cf4         \cf7\ul\b sys_check_timeouts\cf4\b0 ();\cf0\ulnone\par
\par
\cf4     \}\cf0\par
\cf4\}\cf0\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // Called by lwIP Library. Toggles the led when a command is received by the\cf0\par
\cf1 // HTTP \ul webserver\ulnone .\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\cf3\b void\cf4\b0  \b httpLEDToggle\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     \cf1 // Toggle the LED D1 on the control card.\cf0\par
\cf4     \cf1 //\cf0\par
\cf4     GPIO_togglePin(DEVICE_GPIO_PIN_LED1);\cf0\par
\cf4\}\cf0\par
\par
\par
\cf1 //*****************************************************************************\cf0\par
\cf1 //\cf0\par
\cf1 // Called by lwIP Library. Could be used for periodic custom tasks.\cf0\par
\cf1 //\cf0\par
\cf1 //*****************************************************************************\cf0\par
\par
\cf6 uint32_t\cf4  cnt_ms_lwip_Htimer=0;\cf0\par
\cf6 uint32_t\cf4  cnt_ms_TX_Htimer=0;\cf0\par
\cf3\b void\cf4\b0  \b lwIPHostTimerHandler\b0 (\cf3\b void\cf4\b0 )\cf0\par
\cf4\{\cf0\par
\cf1 //  msTime++;\cf0\par
\par
\cf4     cnt_ms_lwip_Htimer++;\cf0\par
\cf4\}\cf0\par
\cf1 /*  \ul int\ulnone  j=0;\cf0\par
\cf1                    // Stocker \ul les\ulnone  \ul donn\f1\'e9es\ulnone\f0  \ul dans\ulnone  buf_tx\cf0\par
\cf1                    buf_kx[j]= data;\cf0\par
\cf1                    j++;*/\cf0\par
\cf4                 \cf1 //   \ul memcpy\ulnone (\ul &buf_kx\ulnone [j], \ul &addr\ulnone ,\ul sizeof\ulnone (buf_kx));\cf0\par
\cf4                 \cf1 //   \ul memcpy\ulnone (\ul &buf_kx\ulnone , (uint32_t *)\ul &addr\ulnone , \ul sizeof\ulnone (buf_kx));\cf0\par
\cf4                 \cf1 /*   for(j=0;j<PAYLOAD;j++)\cf0\par
\cf1                    \{\cf0\par
\cf1                        \ul memcpy\ulnone (\ul &buf_kx\ulnone , *((uint32_t *)\ul addr\ulnone +j) , \ul sizeof\ulnone (data));\cf0\par
\cf1                    \}*/\cf0\par
\cf4                   \cf1 // j++;\cf0\par
\f2\fs22\par
}
 